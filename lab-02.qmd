---
title: "Lab 02: Data and Reproducibility"
author: Maghfira Ramadhani
execute:
  freeze: auto
  echo: true
  warning: false
  message: false
format: 
  html: default
  pdf: default
---

::: callout-important
## Due date

This lab is due on **Monday, September 22 at 11:59pm**. To be considered on time, the following must be done by the due date:

-   Final `.pdf` file submitted on Gradescope
:::

# Introduction

The main goal is to learn data processsing using tidyverse and introduce you to version control using Github.

## Learning goals

By the end of the lab, you will learn:

1.  [Tidyverse basics](#basics)

2.  [Data wrangling with dplyr](#dplyr)

3.  [Data tidying with tidyr](#tidyr)

# The tidyverse

**A whole "universe" of functions within R**

-   The most powerful, intuitive, and popular approach to data cleaning, wrangling, and visualization in R

**Advantages:**

-   Consistent philosophy and syntax
-   "Verb" based approach makes it more familiar to users of Stata/SAS/SPSS
-   Serves as the front-end for many other big data and ML tools

## Tidying Data

The two most important properties of tidy data are:

1.  Each column is a unique variable.
2.  Each row is a single observation.

![](images/tidy-1.png)

::: smaller
\[Image is from ["R for Data Science"](https://r4ds.had.co.nz/tidy-data.html) by Hadley Wickham & Garrett Grolemund, used under [CC BY-NC-ND 3.0](https://creativecommons.org/licenses/by-nc-nd/3.0/us/)\]
:::

Tidy data is easier to work with, because you have a consistent way of referring to variables and observations. It then becomes easy to manipulate, visualize, and model.

## Wide vs. Long Formats

Both of these data sets display information on heart rate observed in individuals across 3 different time periods:

```{r echo=FALSE}
wide = data.frame(
  name = c("Wilbur", "Petunia", "Gregory"),
  time1 = c(67, 80, 64),
  time2 = c(56, 90, 50),
  time3 = c(70, 67, 101)
)
wide

long = data.frame(
  name = c("Wilbur", "Petunia", "Gregory", "Wilbur", "Petunia", "Gregory", "Wilbur", "Petunia", "Gregory"),
  time = c(1, 1, 1, 2, 2, 2, 3, 3, 3),
  heartrate = c(67, 80, 64, 56, 90, 50, 70, 67, 10)
)
long
```

Which dataframe is in *tidy* format?

**Wide** data:

-   Row = patient. Columns = repeated observations over time.
-   Often easier to take in at a glance (as in a spreadsheet).

**Long** data:

-   Row = one observation. Columns = ID variables + observed variable.
-   Usually easier to clean, merge with other data, and avoid errors.

Tidy data is more likely to be **long**.

-   Most R packages have been written assuming your data is in long format.

"Tidy datasets are all alike but every messy dataset is messy in its own way."\
– Hadley Wickham

## Tidyverse packages

We need to install and load a couple of packages. Run these preliminaries:

```{r, eval=T}
#| label: package manager
# load and install package if necessary
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
  tidyverse,
  nycflights13
  )
```

We see that we have actually loaded a number of packages (which could also be loaded individually): **ggplot2**, **tibble**, **dplyr**, etc. - We can also see information about the package versions and some [namespace conflicts](https://raw.githack.com/uo-ec607/lectures/master/04-rlang/04-rlang.html#59).

The tidyverse actually comes with a lot more packages than those that are just loaded automatically.

```{r tverse_pkgs}
tidyverse_packages()
```

All of these are super useful

-   **lubridate** helps us work with dates
-   **rvest** is for webscraping

This labs will focus on two that are automatically loaded: **dplyr** and **tidyr**.

### Pipes: \|\> or %\>%

Pipes take the **output** of one function and feed it into the **first argument** of the next (which you then skip).

`dataframe |> filter(condition)` is equivalent to `filter(dataframe, condition)`.

Note: `|>` on these slides is generated by the two characters `| >`, without the space.

<br> **Older version** of the pipe: `%>%` \* From the `magrittr` package loaded with the tidyverse \* Works identically to `|>` in most situations.

<br> **Keyboard shortcut:** Ctl/Cmd + Shift + M

-   Have to turn on a setting in RStudio options to make `|>` the default

Pipes can dramatically improve the experience of reading and writing code. Compare:

\AddToHookNext{env/Highlighting/begin}{\small}

```{r, eval = T}
## These next two lines of code do exactly the same thing.

mpg |> filter(manufacturer=="audi") |> 
  group_by(model) |> 
  summarize(hwy_mean = mean(hwy))

summarize(group_by(filter(mpg, manufacturer=="audi"), model), hwy_mean = mean(hwy))
```

The first line reads from left to right, exactly how you think about the operations.

The second line totally inverts this logical order (the final operation comes first!)

Best practice is to put each function on its own line and indent. Look how much more readable this is:

\AddToHookNext{env/Highlighting/begin}{\small}

```{r pipe, eval=T}
mpg |> 
  filter(manufacturer == "audi") |> 
  group_by(model) |> 
  summarize(hwy_mean = mean(hwy))
```

Vertical space costs nothing and makes for much more readable/writable code than cramming things horizontally.

All together, this multi-line line of code is called a **pipeline**.

### Key dplyr verbs

**There are five key dplyr verbs that you need to learn.**

1.  `filter`: Filter (i.e. subset) rows based on their values.

2.  `arrange`: Arrange (i.e. reorder) rows based on their values.

3.  `select`: Select (i.e. subset) columns by their names:

4.  `mutate`: Create new columns.

5.  `summarize`: Collapse multiple rows into a single summary value.

Let's practice these functions together using the `starwars` data frame that comes pre-packaged with dplyr.

# Exercise 1: dplyr::filter

![](images/filter.png)

We can chain multiple filter commands with the pipe (`|>`), or just separate them within a single filter command using commas.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r filter1, eval=T}
starwars |> 
  filter( 
    species == "Human", 
    height >= 190
    ) 
```

Regular expressions work well too.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r filter2, eval=T}
starwars |> 
  filter(str_detect(name, "Skywalker"))
```

A very common `filter` use case is identifying (or removing) missing data cases.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r filter3, eval=T}
starwars |> 
  filter(is.na(height))
```

To remove missing observations, simply use negation: `filter(!is.na(height))`.\
Try this yourself.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r filter4, eval=T}
clean_starwars<-starwars |> 
  filter(is.na(height))
clean_starwars
```

# Exercise 2: dplyr::arrange

![](images/arrange.png)

`arrange` sorts your data frame by a particular column (numerically, or alphabetically)

\AddToHookNext{env/Highlighting/begin}{\small}

```{r arrange1, warning=F, eval=T}
starwars |> 
  arrange(birth_year)
```

We can also arrange items in descending order using `arrange(desc())`.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r arrange2, eval=T}
starwars |> 
  arrange(desc(birth_year))
```

# Exercise 3: dplyr::select

![](images/select.png)

Use commas to select multiple columns out of a data frame. (You can also use "first:last" for consecutive columns). Deselect a column with "-".

\AddToHookNext{env/Highlighting/begin}{\small}

```{r select1, eval=T}
starwars |> 
  select(name:skin_color, species, -height)
```

You can also rename some (or all) of your selected variables in place.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r select2, eval=T}
starwars |>
  select(alias=name, planet=homeworld) 
```

If you just want to rename columns without subsetting them, you can use `rename`. Try this!

\AddToHookNext{env/Highlighting/begin}{\small}

```{r rename, eval=T}
starwars_rename<-starwars |>
  rename(alias=name) 
names(starwars_rename)
```

The `select(contains(PATTERN))` option provides a nice shortcut in relevant cases.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r select3, eval=T}
starwars |> 
  select(name, contains("color"))
```

Some other selection helpers: `starts_with()`, `ends_with()`, `all_of(c("name1", "name2"))`, `matches()`.

------------------------------------------------------------------------

# Exercise 4: dplyr::mutate

![](images/mutate.png)

You can create new columns from scratch, or (more commonly) as transformations of existing columns.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r mutate1, eval=T}
starwars |> 
  select(name, birth_year) |>
  mutate(dog_years = birth_year * 7) |>
  mutate(comment = paste0(name, " is ", dog_years, " in dog years."))
```

*Note:* `mutate` is order aware. So you can chain multiple mutates in a single call.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r mutate2, eval=T}
starwars |> 
  select(name, birth_year) |>
  mutate(
    dog_years = birth_year * 7,     # Separate with a comma
    comment = paste0(name, " is ", dog_years, " in dog years.")
    )
```

Boolean, logical and conditional operators all work well with `mutate` too.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r mutate3, eval=T}
starwars |> 
  select(name, height) |>
  filter(name %in% c("Luke Skywalker", "Anakin Skywalker")) |> 
  mutate(tall1 = height > 180) |>
  mutate(tall2 = if_else(height > 180, "Tall", "Short"))

```

Lastly, combining `mutate` with `across` allows you to easily perform the same operation on a subset of variables.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r, mutate4, eval=T}
starwars |> 
  select(name:eye_color) |> 
  mutate(across(where(is.character), toupper))
```

# Exercise 5: dplyr::summarize

![](images/summarize.png) ![](images/group_by.png)

Particularly useful in combination with the `group_by` command.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r summ1, eval=T}
starwars |> 
  group_by(species) |> 
  summarize(mean_height = mean(height))
```

Notice that some of these summarized values are missing. If we want to ignore missing values, use `na.rm = T`:

\AddToHookNext{env/Highlighting/begin}{\small}

```{r summ2, eval=T}
## Much better
starwars |> 
  group_by(species) |> 
  summarize(mean_height = mean(height, na.rm = T))
```

The same `across`-based workflow that we saw with `mutate` a few slides back also works with `summarize`.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r, summ3, eval=T}
starwars |> 
  group_by(species) |>
  summarize(across(where(is.numeric), mean))
```

The same `across`-based workflow that we saw with `mutate` a few slides back also works with `summarize`. Though to add arguments, we have to use an **anonymous function:**

\AddToHookNext{env/Highlighting/begin}{\small}

```{r, summ4, eval=T}
starwars |> 
  group_by(species) |>
  summarize(across(where(is.numeric), ~ mean(.x, na.rm=T)))
```

------------------------------------------------------------------------

### Other dplyr goodies

`ungroup`: For ungrouping after using `group_by`. - Use after doing your grouped `summarize` or `mutate` operation, or everything else you do will be super slow.

`slice`: Subset rows by position rather than filtering by values. - E.g. `starwars |> slice(1:10)`

`pull`: Extract a column from as a data frame as a vector or scalar. - E.g. `starwars |> filter(sex=="female") |> pull(height)`

`distinct` and `count`: List unique values, with or without their number of appearances. - E.g. `starwars |> distinct(species)`, or `starwars |> count(species)` - `count` is equivalent to `group_by` and `summarize` with `n()`:

```{r, eval=T}
starwars |> group_by(species) |> summarize(n = n())
```

------------------------------------------------------------------------

# Challenge 1

**List the most common eye colors among female Star Wars characters in descending order of frequency.**

As usual, there are multiple solutions.

```{r}
starwars |>
  filter(sex == "female") |>
  count(eye_color) |>
  arrange(desc(n))
```

```{r}
starwars |> 
  filter(sex == "female") |>
  group_by(eye_color) |> 
  summarize(n = n()) |>
  arrange(desc(n))
```

Explain what each line in the codes do:

**Answer:**

starwars \|\> means we are pulling from the starwars dataset

filter() keeps only rows where sex is equal to female

count() counts the number of characters for each unique value in the eye_color column. It automatically creates a new column n with the counts.

arrange(desc(n)) sorts results in descending order of n

group_by() groups by eye color

summarize() computes number of rows with n()

### Storing results in memory

So far we haven't been saving the dataframes that result from our code in memory. Usually, we will want to use them for the next task. Create a new object each time you write a pipeline.

```{r, eval=FALSE}
women = starwars |> filter(sex == "female")
brown_eyed_women = women |> filter(eye_color == "brown")
```

Resist the temptation to use the same object name. This is called **clobbering** since it overwrites the previous version. It ruins your ability to easily go back to previous steps.

```{r, eval=FALSE}
# DON'T do this
starwars = starwars |> filter(sex == "female")
```

By keeping multiple copies of very similar dataframes, will you waste your computer's memory? Usually, no -- R is smart and stores only the changes between objects.

### Key tidyr verbs

1.  `pivot_longer`: Pivot wide data into long format.

2.  `pivot_wider`: Pivot long data into wide format.

3.  `separate`: Separate (i.e. split) one column into multiple columns.

4.  `unite`: Unite (i.e. combine) multiple columns into one.

</br>

Which of `pivot_longer` vs `pivot_wider` produces "tidy" data?

# Exercise 6: tidyr::pivot_longer

\AddToHookNext{env/Highlighting/begin}{\small}

```{r pivot_longer1, eval=T}
stocks = data.frame( ## Could use "tibble" instead of "data.frame" if you prefer
  time = as.Date('2009-01-01') + 0:1,
  X = rnorm(2, 10, 1),
  Y = rnorm(2, 10, 2),
  Z = rnorm(2, 10, 5)
  )
stocks
tidy_stocks = stocks |> 
  pivot_longer(cols=X:Z, names_to="stock", values_to="price")
tidy_stocks
```

# Exercise 7: tidyr::pivot_wider

Now we can use pivot_wider to go back to the original dataframe:

\AddToHookNext{env/Highlighting/begin}{\small}

```{r pivot_wider1, eval=T}
tidy_stocks |> pivot_wider(names_from=stock, values_from=price)
```

Or, we can put it into a new ("transposed") format, in which the observations are stocks and the columns are dates:

\AddToHookNext{env/Highlighting/begin}{\small}

```{r pivot_wider2, eval=T}
tidy_stocks |> pivot_wider(names_from=time, values_from=price)
```

# Exercise 8: tidyr::separate

`separate` helps when you have more than one value in a single column:

\AddToHookNext{env/Highlighting/begin}{\small}

```{r sep1, eval=T}
economists = data.frame(name = c("Adam_Smith", "Paul_Samuelson", "Milton_Friedman"))
economists
economists |> separate(name, c("first_name", "last_name")) 
```

--

This command is pretty smart. But to avoid ambiguity, you can also specify the separation character with the `sep` argument:

\AddToHookNext{env/Highlighting/begin}{\small}

```{r, eval=T}
economists |> separate(name, c("first_name", "last_name"), sep = "_")
```

# Exercise 9: tidyr::separate

Related is `separate_rows`, for splitting cells with multiple values into multiple rows:

\AddToHookNext{env/Highlighting/begin}{\small}

```{r sep2a, eval=T}
jobs = data.frame(
  name = c("Joe", "Jill"),
  occupation = c("President", "First Lady, Professor, Grandmother")
  ) 
jobs
# Now split out Jill's various occupations into different rows
jobs |> separate_rows(occupation)
```

Related is `separate_rows`, for splitting cells with multiple values into multiple rows:

\AddToHookNext{env/Highlighting/begin}{\small}

```{r sep2, eval=T}
jobs = data.frame(
  name = c("Joe", "Jill"),
  occupation = c("President", "First Lady, Professor, Grandmother")
  ) 
jobs
# Now split out Jill's various occupations into different rows
jobs |> separate_rows(occupation, sep = ", ")
```

# Exercise 10: tidyr::unite

\AddToHookNext{env/Highlighting/begin}{\small}

```{r unite1, eval=T}
gdp = data.frame(
  yr = rep(2016, times = 4),
  mnth = rep(1, times = 4),
  dy = 1:4,
  gdp = rnorm(4, mean = 100, sd = 2)
  )
gdp 
## Combine "yr", "mnth", and "dy" into one "date" column
gdp |> unite(date, c("yr", "mnth", "dy"), sep = "-")
gdp_u <- gdp |> unite(date, c("yr", "mnth", "dy"), sep = "-")
```

Note that `unite` will automatically create a character variable.

If you want to convert it to something else (e.g. date or numeric) then you will need to modify it using `mutate`. This example uses the [lubridate](https://lubridate.tidyverse.org/) package's super helpful date conversion functions.

\AddToHookNext{env/Highlighting/begin}{\small}

```{r unite3, message=F, eval=T}
library(lubridate)
gdp_u |> mutate(date = ymd(date))
```

------------------------------------------------------------------------

# Challenge 2

**Using `nycflights13`, create a table of average arrival delay (in minutes) by day (in rows) and carrier (in columns).**

Hint: Recall that you can tabulate summary statistics using `group_by` and `summarize`:

```{r}
flights |> 
  group_by(carrier) |> 
  summarize(avg_late = mean(arr_delay, na.rm=T))
```

Solution:

```{r message=FALSE}
delay_long = flights |> 
  group_by(carrier, day) |> 
  summarize(avg_late = mean(arr_delay, na.rm=T))
delay_wide = delay_long |> 
  pivot_wider(names_from=carrier, values_from=avg_late)
head(delay_wide, 4)
```

Explain what each line in the codes do:

**Answer:**

delay_long stores the flights data from flights

group_by() groups by both carrier and day

summarize() finds average delay

delay_long stores data from delay_long

pivot_wider changes data to a wide format

head() dsplays first 4 rows of delay_wide

# Create GitHub Account

Go to github.com and sign up to create an account. Report your GitHub username via this form:

[GitHub SignUp Report Form](https://forms.office.com/r/w5HQepaeCe)

# Submission

You will submit the PDF documents in to Gradescope as part of your final submission.

::: callout-warning
Remember -- you must turn in a PDF file to the Gradescope page before the submission deadline for full credit.

Instructions to combine PDFs:

-   Preview (Mac): [support.apple.com/guide/preview/combine-pdfs-prvw43696/mac](https://support.apple.com/guide/preview/combine-pdfs-prvw43696/mac)

-   Adobe (Mac or PC): [helpx.adobe.com/acrobat/using/merging-files-single-pdf.html](https://helpx.adobe.com/acrobat/using/merging-files-single-pdf.html)
:::

To submit your assignment:

-   Access Gradescope

-   Click on the assignment, and you’ll be prompted to submit it.

-   Mark the pages associated with each exercise. All of the pages of your lab should be associated with at least one question (i.e., should be “checked”).

-   Select the first page of your .PDF submission to be associated with the *“Workflow & formatting”* section.

# Grading

| Component               | Points |
|:------------------------|:-------|
| Replicating Ex 1-10     | 85     |
| Challenge               | 5      |
| Creating Github Account | 5      |
| Workflow & formatting   | 5      |

The "Workflow & formatting" grade is to assess the reproducible workflow and document format.
